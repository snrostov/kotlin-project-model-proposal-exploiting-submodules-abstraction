Covered points checklist:

* âœ… Make simple/popular cases easy
* âœ… Make complex cases possible
* âœ… Intuitive model
* âœ… Gradual increase of complexity
* âŒ Co-exist with platform project models (conceptually)
* âŒ Re-use knowledge of Gradle and Android
* âœ… Separate a core project model that can be expressed in a static config file (not in code)

* âœ… In simple cases people do not want to understand our model
* âœ… Users just take a simple example and modify it intuitively without digging into the docs

Specific cases:
* âœ… I look at some multiplatform module and want to easily understand for which platform binaries it is compiled
* âœ… I look at some source-file and want to understand which code is correct here and which is not
* âœ… I have two multiplatform modules/module bundles/whatever they are called. I want to add dependency(ies) between them. I need to know how to do it and how it affects visibility of a source-code
* Q: How much abstractions I have to learn and DSL to write when
    * ğŸ‘‰ `module` is well known abstraction
    * ğŸ‘‰ `private submodule` introduced (replacement for both compilations and sources sets). The nice thing is that should be part of public module by definition, so public module contains all private submodules.
    * ğŸ‘‰ `taregts` is expressed using the `private submodule` exposed as a `variant` of parent `public module`
    * ğŸ‘‰ `dependsOn` is expressed as private submodules `parent-child` relationship
    * ğŸ‘‰ `test internal visibility` also expressed submodules parent-child relationship
    * implicit tests  `dependsOn` visibility expressed as `supplementary` submodule concept
        * also work for custom supplementaries such as integrationTests, benchmarks and so on
    * ğŸ‘‰ `hmpp` is modeled as grouping `submodule` into another `submodule` and `multiparent submodules` (`extends` directive)
    * ğŸ‘‰ other build dimensions supported
* âœ… How easy it is to migrate single-platform project to multiplatform project
    * ğŸ‘‰ just add new `target` directive
* How natural and consistent it is to select some sub-set of sources to change something for it by:
    * By target (e.g. set macos64-specific settings)
        * ğŸ‘‰ just write in target's dsl block
    * By platform (e.g. set JS-settings)
        * ğŸ‘‰ targets is grouped by platform
    * By main/test (e.g. adjust assertions, experimental annotations, etc.)
        * ğŸ‘‰ just write in root test, all target's tests have additional implicit parent on them, so settings are derived
    * By debug/release (turn on optimizations, minification, etc.)
        * ğŸ‘‰ same as tests, but using custom dimensions
    * By native binary type (configure something for all iOS frameworks)
        * ğŸ‘‰ not sure what it should mean. same as above?
    * Something-something about tests
        * ğŸ‘‰ dependencies on other modules public tests works 