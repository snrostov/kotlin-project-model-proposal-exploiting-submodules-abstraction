class Declaration(override val id: Id) : Identifiable

class Dependencies {
    private val declarationUsages = mutableMapOf<Ref<Declaration>, MutableList<Ref<Declaration>>>()
    private val declarationDependencies = mutableMapOf<Ref<Declaration>, MutableList<Ref<Declaration>>>()

    val Ref<Declaration>.usages: Collection<Ref<Declaration>>
        get() = declarationUsages.getOrDefault(this, listOf())

    val Ref<Declaration>.declarations: Collection<Ref<Declaration>>
        get() = declarationDependencies.getOrDefault(this, listOf())

    fun add(from: Ref<Declaration>, to: Ref<Declaration>) {
        declarationUsages.getOrPut(from) { mutableListOf() }.add(to)
        declarationDependencies.getOrPut(to) { mutableListOf() }.add(from)
    }
}

class Changes<I : Identifiable>(
    val new: Collection<I>,
    val removed: Collection<I>,
    val changed: Collection<Pair<I, I>>
) {
    fun <O> map(f: (old: I?, new: I?) -> O): Collection<O> {
        return new.map { f(null, it) } +
                removed.map { f(it, null) } +
                changed.map { f(it.first, it.second) }
    }
}

class Transformation<I : Identifiable, O : Identifiable> {
    class Context<I : Identifiable, O : Identifiable> {
        fun use(input: Ref<I>): Ref<I> = TODO()
    }

    fun transform() {

    }
}