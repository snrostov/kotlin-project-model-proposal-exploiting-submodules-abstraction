## Project model

`Module` - an application that you can run or library that you can depend on.

### File layout

Module is just a directory with a `kotlin-module` file inside and on or more `*.kt` files. 
`kotlin-module` file contains module definition and may be empty.

Example:
```
/ToDoApp
    kotlin-module
    app.kt
```

kotlin-module:
```
kotlin 1.5
module github.com/username/libname  # optional module identifier that used to refer that module as a dependency
pacakge libname                     # optional package name that is used in fully qualified names

import stdlib                       # see next section
```

app.kt:
```kotlin
println("hello, world!")
```

### Module dependencies

The module can depend on other modules by using `import` or `public import` directive.
By default all imports are exposed to the module users.
This may be changed by using `private import` directive instead. 

![](img/imgs/dependencies.svg)

```
module kotlin.org/samples/ToDoApp

import kotlin.org/stdlib
private import kotlin.org/uiLib
private import kotlin.org/datesLib
```

```
module kotlin.org/uiLib

import kotlin.org/ui
private import kotlin.org/uiJuggler 
```

### Target platform

Each module produces a platform-specific artifact: executable or library.
Platform is configured using the `target` directive.

```
module kotlin.org/samples/ToDoApp

import kotlin.org/stdlib
private import kotlin.org/uiLib
private import kotlin.org/datesLib

target android
```

The module can have multiple artifacts, for example for different platforms.
In this case, all dependencies and all sources should be compatible with declared target platforms.

```
module kotlin.org/dateUtils

import kotlin.org/dates

target jvm
target js
```

### Submodules and tests

The module can have `public` and `private` `submodules`.
Submodules derives most of parent module settings: kotlin version, targets and other.

Submodules is declared by just creating subdirectory.
`kotlin-module` file is not required in that subdirectory.
By default submodules have public visibility and it's package name is changed to sub directory name.
Submodule info can be placed inside parent's `kotlin-module` under the `module`/`private module` directive
or with it's own `kotlin-module` file inside subdirectory.

Submodules has an implicit import of parent module and can see its public and internal declarations.
Parent module also have implicit import of all public submodules, but can see only it's public declarations.
Private submodules is not imported by default.

Public submodules is replacement for kotlin packages.

On of use case of private submodules is supplementary things like tests, integration tests, benchmarks and so on.
There is predefined directive for creating private test submodule: `test`.

```
/ToDoApp
    kotlin-module
    App.kt
    /test
        AppTest.kt
    /utils
        dates.kt
        /test
            datesTest.kt
```

/ToDoApp/kotlin-module:
```
module kotlin.org/samples/ToDoApp

import kotlin.org/stdlib

test {   
    import kotlin.org/test
}

module utils {
    test {
        import kotlin.org/test
    }
}
```

![](img/imgs/submodules.svg)

Alternatively, submodule files can be named as `filename.submodule-name.kt` and placed in parent directory.
Example:

 ```
 /ToDoApp
     kotlin-module
     App.kt
     App.test.kt
     /utils
         dates.kt
         dates.test.kt
 ```

### Implicit parent-child tests relationship

In previous example, we are explicitly define dependency from `utils/test` to `kotlin.org/test`.
But it is already defined in root `test` module and it would be nice if that dependency was derived in same way as it appears for submodule relationship.
The problem is that `test` is not parent for `utils/test`.
But we can infer that additional parent-child relationship between submodule supplementary of same kinds (`test` in this case). 

![](img/imgs/submodule-relations.svg)

This implicit supplementary parent-child relationship useful in case of many related submodule which is frequently appears in advanced multi-platform cases.
This cases described below.

As an advanced concept, your may define your own supplementary kinds or even dimensions of that kinds.
This is described in the further sections.

### Multiplatform modules with platform specifics

It is possible to create a multiplatform module that have specific platform code. 
Platform specifics can be declared in private submodules that can be exposed as a so called `variant` of the parent public module. 
Actually, the `target` declaration already creates a private submodule and exposed as a `module variant`.

Example:

```
module kotlin.org/dateUtils

import kotlin.org/dates

target jvm
target js
```

Files:

```
/dateUtils
    kotlin-module
    dateUtils.kt
    /jvm
        dateUtils.kt
    /js
        dateUtils.kt
```

or

```
/dateUtils
    kotlin-module
    dateUtils.kt    
    dateUtils.jvm.kt    
    dateUtils.js.kt
```

Target's private submodule can have it's own target specific imports and settings. 
All the setting can be declared under target directive or inside it's own `kotlin-module` file inside subdirectory

```
module kotlin.org/dateUtils

import kotlin.org/dates

target jvm {
    import java.utils.date
}

target js {
    import moment.js
}
```

### Variant aware dependency resolution

Dependency to the module with multiple variants are resolved in special way: user of that module will see only peaces of required variant.
Let's take a look to example of two jvm/js dependent modules: `dateUtils` described in the previous section and `uiUtils` described below.

```
module kotlin.org/uiUtils

import kotlin.org/dateUtils

target jvm
target js
```

![](img/imgs/variant-aware-1.svg)

Despite the fact that we declared only one import to `kotlin.org/dateUtils`, our `uiUtils` `jvm` variant automatically will import `jvm` part of  `kotlin.org/dateUtils` (but not `js` ). The same for js: it will automatically import `js` part of `kotlin.org/dateUtils`. 

![](img/imgs/variant-aware-2.svg)

This feature is called `variant aware dependency resolution` and prevents us to duplicate dependencies in each target manually.

### Platform-specific declarations

The general way to extract platform-specific code is building a set of interfaces in the common code and implementing these interfaces in platform-specific modules. However, this approach is not ideal in cases when you have a library on one of the platforms that implements the functionality you need, and you'd like to use the API of this library directly without extra wrappers. Also, it requires common declarations to be expressed as interfaces, which doesn't cover all possible cases.

As an alternative, Kotlin provides a mechanism of `expected` and `actual` declarations. With this mechanism, a common code can define expected declarations, and a platform specific code can provide actual declarations corresponding to the expected ones. To see how this works, let's look at an example first. This part of root common code:

```kotlin
expect class Foo(bar: String) {
    fun frob()
}

fun main() {
    Foo("Hello").frob()
}
```  

And this is the corresponding JVM variant private submodule:

```kotlin
actual class Foo actual constructor(val bar: String) {
    actual fun frob() {
        println("Frobbing the $bar")
    }
}
```

.... https://kotlinlang.org/docs/reference/platform-specific-declarations.html

### Common code for group of platforms

```
module kotlin.org/dateUtils

import kotlin.org/dates

target jvm

target js {
    target browser
    target nodejs
}

target native {
    target iOS
    target macOS
}
```

```
/ToDoApp
    common.kt
    /jvm/app.kt
    /js
        jsCommon.kt
        /browser/app.kt
        /nodejs/app.kt
    /native
        nativeCommon.kt
        /iOS/app.kt
        /macOS/app.kt
```

### Multiparent private submodules

Sometimes you need to use extract traits that should be combined into different platforms.


```
module kotlin.org/dateUtils

import kotlin.org/dates

private module managed-memory-common

target jvm {
    extends managed-memory-common
}

target js {
    extends managed-memory-common
}

target iOS
```

```
/ToDoApp
    common.kt
    /managed-memory-common/common.kt
    /jvm/app.kt
    /js/app.kt    
```

### Exposing tests as public module variant

You can expose test submodules as parent public variant. In this case, users of your module can see declaration of your test submodules in their corresponding test modules.

This will work for all supplementary modules.

### Imported vs child submodules

When you choosing between external module that you can import and submodule, you should understand differences described below.

Only child submodule can:
- see internal declarations of parent module
- create actual declarations for parent module

Module that have an import to another module can't do this things.

### Custom platforms and variants

```
target jvm {
    target 8 {
        attribute jvm-version 1.8
    }
}
```

### Custom supplementary kind

Actually `test` is just shorthand for `supplementary module test`.
You can define any supplementary modules:

```
supplementary module benchmarks {
    
}
``` 

And the will have corresponding implicit parent-child relationship between submodules.

### Custom build dimensions

Above we have used only 2 predefined build dimensions: `platform` (`jvm`/`js`/`native`) and `supplementary kind` (`root`/`test`/`becnhamrks`).

Let's declare one more dimensions, for example `optimizations-level` (`dev`/`prod`).

```
target jvm {
    tests {
        dev
        prod
    }

    dev
    prod
}
```

--------

Comparing to the current model:

- `main`/`tests`/`becnhmarks`/`whatever` - `supplementary` public or private submodules
- `target` = `private submodule` exposed as a `variant` of parent `public module`
- `sources sets` and `compilation` of specific targets = `private submodule`
- `depends on` = `parent` of `private submodule`
- `hmpp` = `private submodule groups` and `multiparent private submodules`

--------

## Execution/artifacts model

