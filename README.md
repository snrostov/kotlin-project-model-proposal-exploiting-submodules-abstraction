# Kotlin Project model proposal

Please don't care about `kotlin.mod` file format, it is just a stub to show the idea.

## High level Project Model

`Module` - an application that you can run or library that you can depend on. The key property of module is that it should be defined in one place. Or, in other words, you cannot define part of module, publish it and define other parts later.

### File layout

Module is just a directory with a `kotlin.mod` file inside and one or more `*.kt` files. 
`kotlin.mod` file contains module definition and may be empty.

```
/ToDoApp
    kotlin.mod
    app.kt
```

```kotlin
// kotlin.mod
module ToDoApp {
    dependsOn(stdlib)
}
```

```kotlin
// app.kt
fun main() = println("hello, world!")
```

### Dependencies

The module can depend on other modules by using `dependsOn(module)`. By default, module can see declarations only for it's own dependencies, not dependencies of dependencies and so on. It may be changed by specifine `export` parameter: `dependsOn(module, export = true)`.

```kotlin
module ToDoApp {
    dependsOn(stdlib, export = true)
    dependsOn(uiLib)
}
```

```kotlin
module uiLib {
    dependsOn(ui, export = true)
    dependsOn(uiJuggler )
}
```

![](img/imgs/dependencies.svg)

### Submodules

Submodules is declared by just creating subdirectory (even without `kotlin.mod` file inside).

By default submodules cannot access to parent declarations, but parent has an implicit exported dependency on child one. Thus parent has access to public declarations of child module. Also, folder name is used for relative module and namespce name by default.

You can configure submodule inside parent's `kotlin.mod` using or with it's own `kotlin.mod` file inside subdirectory. Submodule can have it's own imports and other settings.

```
/myApp
    kotlin.mod
    app.kt
    /utils
        strings.kt
        dates.kt
```

```kotlin
module myApp {
    module utils {
        dependsOn(kotlinDates)
    }
}
```

### Inner modules

Sometimes submodule need access to parent module. You can achive it by marking child module as `inner`.

Try avoid using `inner` modules as they are coupled with parent: inner modules always get compiled and published together, so they cannot be compiled in parallel. You should use `inner` modules only when you need both access to the parent from child and from child to parent.

`inner module` derives all settings from parent module (i.e. dependencies, targets, plugins). Currently, `inner modules` may contain only `inner modules` iteself.

```
/myApp
    kotlin.mod
    serviceManager.kt
    /storageService
        storageService.kt
```

```kotlin
module myApp {
    inner module storageService
}
```

### Tests and other helpers

In test submodules, you need reversed parent-child dependency: tests should see parent declarations (including internals), but parent should know nothing about tests. You can achive this by using `helper` submodules.

There is shorthand for creating test helper submodule: you can type just `test`.

```
/ToDoApp
    kotlin.mod
    App.kt
    /test
        AppTest.kt
    /utils
        dates.kt
        /test
            datesTest.kt
```

```kotlin
module ToDoApp {
    dependsOn(stdlib)

    test { 
        import kotlin-test
    }

    module utils {
        test {
            import kotlin-test
        }
    }
}
```

![](img/imgs/submodules.svg)

You can define custom helper modules:

```
helper benchmarks {
    import kotlin-benchmarks
}
```

Submodules is not allowed in `helper` modules.

### Target platform

Each module produces a platform-specific artifact: executable or library.
Platform is configured by calling correspoing platorm specific configurator.

```kotlin
module ToDoApp

import stdlib

android {}
```

The module can have multiple artifacts, for example for different platforms.
In this case, all dependencies and all sources should be compatible with declared target platforms.

```kotlin
module dateUtils

import dates

jvm {}
js {}
```

### Multiplatform modules with platform specifics

It is possible to create a multiplatform module that have specific platform code.

Platform specifics can be declared in special `target` submodule.

Actually, the `android`/`jvm`/`js` configurators already creates a `target` submodule with corresponded name. So, you can just put your platform specific sources under the `android`, `jvm` and `js` directories.

Files:

```
/dateUtils
    kotlin.mod
    dateUtils.kt
    /jvm
        dateUtils.kt
    /js
        dateUtils.kt
```

```
module dateUtils

import kotlin-dates

jvm {
    import java.util.date
}

js {
    import moment-js
}
```

`target` submodules is somewhat similar to `helper` (test) submodules. They also have reversed parent-child dependency: child sees parent declarations, but becomes totally invisible from parent side. 

Among this, `target` also introduces new concept for parent module when it used as dependency. Each `target` submodule defines a _variant_ of parent module. Dependency to the module with multiple variants are resolved in special way: user of that module will see only peaces of required variant. Let's take a look at example with two dependent multiplatform modules: `dateUtils` described above and `uiUtils` that depends on `dateUtils`:

```
module uiUtils

import dateUtils

jvm
js
```

![](img/imgs/variant-aware-1.svg)

Despite the fact that we declared only one import of `dateUtils`, `jvm` variant of `uiUtils` automatically will import `jvm` part of `dateUtils` (but not `js`). The same for js: it will automatically import `js` part of `dateUtils`. 

![](img/imgs/variant-aware-2.svg)

This feature is called `variant aware dependency resolution` and prevents us to duplicate dependencies in each target manually.

As an advanced concept, you can [declare targets manually]() or even introduce your own platforms.

### Using platform declarations from common code

Sometimes you need to write common code that may use declarations from platforms specific code, assuming that all platforms have same or compatiable signatures of that declarations.

You can do that by declaring `except`'ed declarations in common code, and providing `actual` declarations in all platforms.

```
/dateUtils
    kotlin.mod
    dateUtils.kt
    /jvm
        dateUtils.kt
    /js
        dateUtils.kt
```

```kotlin
module dateUtils

import kotlin-dates

jvm {
    import java.util.date
}

js {
    import moment-js
}
```

common:
```kotlin
except fun secondOfDay(timestamp: Long): Int

fun minuteOfDay(timestamp: Long) =
    secondOfDay(timestamp) / 60
```

jvm:
```kotlin
actual fun dateFromTimestamp(timestamp: Long) =
    DateTime.from(timestamp).minuteOfDay()
```

js:
```kotlin
actual fun dateFromTimestamp(timestamp: Long) =
    Date(timestamp).minuteOfDay
```

All `target` modules should provide exactly one `actual` declaration for `except` declaration from parent module. Providing excepted declarations allowed only for `target` submodules. This is not allowed for regular submodules, `helper` or dependent modules. 

The process of providing actuall declarations is called _refinement_, so `target` submodules _refines_ parent one.

### Common code for group of platforms

In more complicated cases, you may want to write some specific code for subset of targets (not for all targets). You can achive it by nesting targets, but the problem is that you  middle targets may not be fully defined: some `actual` declarations still can be missed or you just don't need to publish them.

`refinement` module exactly for that middle target case. This is the same as `target` module, but they not exposed as module variant and they may have missed `actual` declarations.

```kotlin
module kotlin.org/dateUtils

import kotlin.org/dates

jvm {}

refinement js {
    browser {}
    nodejs {}
}

refinement native {
    iOS {}
    macOS {}
}
```

```
/ToDoApp
    common.kt
    /jvm/app.kt
    /js
        jsCommon.kt
        /browser/app.kt
        /nodejs/app.kt
    /native
        nativeCommon.kt
        /iOS/app.kt
        /macOS/app.kt
```

### Custom refinement

In the most advanced cases, you may need to extract traits that should be combined into different targets and not fit in the one hierarchy. In that cases you can define `refine` relations manually.

```kotlin
module kotlin.org/dateUtils

import kotlin.org/dates

refinement singleThreaded

refinement managedMemory {
    jvm {
        refines managed-memory-common
    }

    js {
        refines singleThreaded
    }
}

iOS {
    refines singleThreaded
}
```

```
/ToDoApp
    common.kt
    /managed-memory-common/common.kt
    /jvm/app.kt
    /js/app.kt    
```

You can `refine` only `refinement` and `taregts` from parent module. `refine` across module boundaries is not allowed.

### Multiple variant dimensions

TODO: dependencies to upper level refinement

```
refinement common {
    refinement singleThreaded {
        target native {}
    }

    refinement managedMemory {
        target jvm {}
        target js {
            refines(singleThreaded)
        }
    }
}

refinement paid {
    refines(common)
    productLine = paid

    /** same as in common **/
}

refinement free {                    
    refines(common)
    productLine = free

    /** same as in common **/
}
```

### Common tests

The except/actual mechanics maybe also usefull for tests: you may write some common tests with `expect` declarations, and platform tests should provide `actual` declarations.

```
/dateUtils
    kotlin.mod
    dateUtils.kt
    /jvm
        dateUtils.kt        
    /js
        dateUtils.kt                
    /test
        commonDateTests.kts
        /jvm
            jvmAssertionsImpl.kt
        /js
            jsAssertionsImpl.kt
```

```kotlin
module dateUtils

import kotlin-dates

jvm {
    dependsOn(java.util.date)
    test {}
}

js {
    dependsOn(momentJs)
    test {}
}

test {
    jvm { }
    js { }
}
```

`jvm` and `js` part of tests will see the correspoing parts of parent module thanks to variant aware dependency resolution.

## Low level Project Model

Under the hood, things described above is an abtraction over low level primitives.

### Module and Module Variants

__Module__ - a peace of software that should be fully defined in one place and may provide one or more __Module Variant__. The most basic Module consist of one Module Variant.

The Module Variant has:
- A set of Kotlin sources that exposes an API (set of Kotlin declarations)
- __Attribute Values__ for some __Attribute Keys__. This values defines __Module Variants Compatibility__: module variants is compatiable when all of ther attribute values are compatiable.

Each __Attribute Key__ has: 
- __Name__ - unique string
- __Set of valid values__ `V`
- __Values compatibility rule__ `(a: V, b: V?): Boolean`. This rule should form a lattice from the set of valid values.

Dependency from Module to Module (__Module Depedency__) is treated as an implicit dependency between their compatiable Module Variants. This forms __Variant Aware Dependency Resolution__. 

![](img/imgs/ll-variants.svg)

### Fragments: common code between Variants

Module Variants can share their parts using the __Module Fragments__. Among just sharing code, __Module Fragments__ provides an ability to `expect` some declarations in common code and provide different `actual` declarations in variant specific code for the same `expect`'ed declaration. One Module Fragment _refines_  another Module Fragment when they _depending_ on them and provides `actual` delcarations for an `expect`'ed. This dependency is called __Module Fragment Refinement Depedency__. Module Fragments should form a DAG throught this dependencies.

![](img/imgs/ll-fragments.svg)

Taking this in mind, we can redefine Module Variant as such Module Fragment that have `actual` declarations for all `except` declarations from all transetivly refined and dependent module fragments. Module Fragment should be contained in at least one refinement closure of Module Variant.

Module Fragments can still be just depended on each other, without refinement. This is called __Module Fragment Depedency__. This dependency have been implicitly created from the Module Dependency:

![](img/imgs/ll-fragment-deps.svg)

Actually, Module Fragment has Attribute Values too: it is a union of all values from all Module Fragments that refines that module. It is possible to restrict Attribute Values per fragment.

Finally, Module Fragments can inidividually depends on Module. This is still called Module Depedency, but the difference is that more common Module Fragments is not affected by this kind of dependency.

So, the each Module Fragment has:
- A set of Kotlin sources that exposes an API (set of Kotlin declarations)
- __Attribute Values__ that is used to define __Module Fragments Compatibility__. Module Variant Compatibility is a Module Fragments Compatibility.
- __Module Fragment Depedency__ - dependies on other _compatible_ Module Fragments in other Modules. This dependencies forms DAG. Module Variant dependency is a Module Fragment Dependency.
- __Module Fragment Refinement Depedency__ - list of other fragments in this module that is used as "base". Fragment that refines other Fragments also depends on it and sees it's internal declarations. Should also forms DAG. Only refinement Fragment can provide `actual` declarations for `except` declarations of Fragment that it refines.

### Advanced dependency properties

- Module Fragment Depedency can be marked as re-exportable.
- Module Fragment can provide a list of __Friend Module Fragments__ that can see internals when they are depending on that one.
- Module Fragment can also have an __Runtime Module Dependency__ which is always reexported and doesn't affects Module Fragments Dependencies in any way (as it is compile only).

### Mapping to high level model

- plain `module` is _low level module_ with one default _module fragment_.
- plain module has _dependency_ to the all direct child plain submodules.
- contents of `inner` submodules is just mixed into parent submodules
- `helper` submodule is a _low level module_ with one default _module fragment_ that _depends_ on parent
- `target` submodule is a _module variant_ that _refines_ parent
- `refinement` submodule is a _module fragment_ that _refines_ parent
- `dependsOn` is an _module fragment dependency_. Allowed only between _module fragment_ in current module and another module. Dependencies between `refinement`s and `target`s are not allowed.
- `refines` is an _module refinement dependency_. Allowed only between _module fragment_ in current module. 
- `refine`'ment on `refinement`/`target` with child `refinement`s/`target`s are treated in a special way: it create dependency on the all compaitible child `refinement`s/`target`s

### Low level DSL

```
module main {
    fragment common {
        
    }

    variant jvm {
        platform = jvm
        refines(common)
        dependsOn(stdLib)  
    }  
}

module test {
    fragment common {
        dependsOn(main)  
    }

    variant jvm {
        platform = jvm
        refines(common)
    }
}  
```

## DSL evaluation

## Build model and evaluation

## Java

## Gradle

## Android

## JS

## XCode projects