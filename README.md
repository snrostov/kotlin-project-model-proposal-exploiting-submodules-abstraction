# Kotlin Project model proposal

Please don't care about `kotlin.mod` file format, it is just a stub to show the idea.

## Project model

`Module` - an application that you can run or library that you can depend on.

### File layout

Module is just a directory with a `kotlin.mod` file inside and one or more `*.kt` files. 
`kotlin.mod` file contains module definition and may be empty.

```
/ToDoApp
    kotlin.mod
    app.kt
```

```kotlin
// kotlin.mod
module ToDoApp

import stdlib                       
```

```kotlin
// app.kt
println("hello, world!")
```

### Dependencies

The module can depend on other modules by using `import` or `private import` directive.
By default all imports are exposed to the module users.
This may be changed by using `private import` directive instead.

```kotlin
module ToDoApp

import stdlib
private import uiLib
```

```kotlin
module uiLib

import ui
private import uiJuggler 
```

![](img/imgs/dependencies.svg)

### Submodules

The module can have `public` and `private` `submodules`.

Public submodules is replacement for kotlin packages.
Private submodules can be used for supplementary things like tests, integration tests, benchmarks and so on.

Submodules derives parent module settings: targets, dependencies, used plugins and so on.

Submodules is declared by just creating subdirectory (even without `kotlin.mod` file inside).
By default submodules have public visibility and folder name is used for relative module name.

Optionally, submodule info can be placed inside parent's `kotlin.mod` under the `module`/`private module` directive or with it's own `kotlin.mod` file inside subdirectory.

Submodules can see public and internal declarations from parent module.
Parent module can see only public declarations and only from public submodules.
Private submodules is not imported by default.

### Tests: private submodules

There is shorthand for creating `private module test`: you can type just `test`.

```
/ToDoApp
    kotlin.mod
    App.kt
    /test
        AppTest.kt
    /utils
        dates.kt
        /test
            datesTest.kt
```

```kotlin
module ToDoApp

import stdlib

test {   
    import kotlin-test
}

module utils {
    test {
        import kotlin-test
    }
}
```

![](img/imgs/submodules.svg)

#### Implicit parent-child tests relationship

In previous example, we are explicitly define dependency from `utils/test` to `kotlin-test`.
But it is already defined in root `test` module and it would be nice if that dependency was derived in same way as `stdlib` imported in root module accessiable in `utils`.
The problem is that `test` is not parent for `utils/test`.
But we can infer that additional parent-child relationship between submodule supplementary of same kinds (`test` in this case). 

![](img/imgs/submodule-relations.svg)

This implicit supplementary parent-child relationship useful in case of many related submodule which is frequently appears in [advanced multi-platform cases]().

#### Custom supplementary (benchmarks, integration tests...)

Actually `test` is just shorthand for `supplementary module test`.
You can define custom supplementary module:

```
supplementary module benchmarks {
    import kotlin.org/benchmarks
}
```

And the will have corresponding implicit parent-child relationship between submodules.

Supplementary module is private only thing (there is no sense in public supplementary, as it will already published as main code, not supplementary). 

As an advencaed concept, you can define your own build dimensions. This is described in separate section.

### Target platform

Each module produces a platform-specific artifact: executable or library.
Platform is configured using the `target` directive.

```kotlin
module ToDoApp

import stdlib
private import uiLib
private import datesLib

target android
```

The module can have multiple artifacts, for example for different platforms.
In this case, all dependencies and all sources should be compatible with declared target platforms.

```kotlin
module dateUtils

import dates

target jvm
target js
```

### Multiplatform modules with platform specifics

It is possible to create a multiplatform module that have specific platform code.

Platform specifics can be declared in private submodules that can be exposed as a so called `variant` of the parent public module. 
Actually, the `target` declaration already creates a private submodule and exposed as a `module variant`.

Example:

```kotlin
module dateUtils

import kotlin-dates

target jvm
target js
```

Files:

```
/dateUtils
    kotlin.mod
    dateUtils.kt
    /jvm
        dateUtils.kt
    /js
        dateUtils.kt
```

Target's private submodule can have it's own target specific imports and settings. 
All the setting can be declared under target directive or inside it's own `kotlin.mod`.

```
module dateUtils

import kotlin-dates

target jvm {
    import java.util.date
}

target js {
    import moment-js
}
```

### Variant aware dependency resolution

Dependency to the module with multiple variants are resolved in special way: user of that module will see only peaces of required variant.
Let's take a look to example of two jvm/js dependent modules: `dateUtils` described in the previous section and `uiUtils` described below.

```
module uiUtils

import dateUtils

target jvm
target js
```

![](img/imgs/variant-aware-1.svg)

Despite the fact that we declared only one import to `dateUtils`, our `uiUtils` `jvm` variant automatically will import `jvm` part of  `dateUtils` (but not `js` ). The same for js: it will automatically import `js` part of `dateUtils`. 

![](img/imgs/variant-aware-2.svg)

This feature is called `variant aware dependency resolution` and prevents us to duplicate dependencies in each target manually.

### Exposing tests as public module variant

You can expose test submodules as parent public variant in the same way as for platforms. Note that test variants not treated as platform, it adds another `dimension` instead. So, each platform may have own test variant. 

With published tests, users of your module can see declaration of your test submodules in their corresponding test modules for the corresponding platform (and other variant dimensions).

This will work for all supplementary modules benchmarks, integration tests, and whatever you need.

### Platform-specific declarations

The general way to extract platform-specific code is building a set of interfaces in the common code and implementing these interfaces in platform-specific modules. However, this approach is not ideal in cases when you have a library on one of the platforms that implements the functionality you need, and you'd like to use the API of this library directly without extra wrappers. Also, it requires common declarations to be expressed as interfaces, which doesn't cover all possible cases.

As an alternative, Kotlin provides a mechanism of `expected` and `actual` declarations. With this mechanism, a common code can define expected declarations, and a platform specific code can provide actual declarations corresponding to the expected ones. To see how this works, let's look at an example first. This part of root common code:

```kotlin
expect class Foo(bar: String) {
    fun frob()
}

fun main() {
    Foo("Hello").frob()
}
```  

And this is the corresponding JVM variant private submodule:

```kotlin
actual class Foo actual constructor(val bar: String) {
    actual fun frob() {
        println("Frobbing the $bar")
    }
}
```

... https://kotlinlang.org/docs/reference/platform-specific-declarations.html ...

### Common code for group of platforms

```kotlin
module kotlin.org/dateUtils

import kotlin.org/dates

target jvm

private module js {
    target browser
    target nodejs
}

private module native {
    target iOS
    target macOS
}
```

```
/ToDoApp
    common.kt
    /jvm/app.kt
    /js
        jsCommon.kt
        /browser/app.kt
        /nodejs/app.kt
    /native
        nativeCommon.kt
        /iOS/app.kt
        /macOS/app.kt
```

### Multiparent private submodules

Sometimes you need to use extract traits that should be combined into different platforms.

```private
module kotlin.org/dateUtils

import kotlin.org/dates

private module managed-memory-common

target jvm {
    extends managed-memory-common
}

target js {
    extends managed-memory-common
}

target iOS
```

```
/ToDoApp
    common.kt
    /managed-memory-common/common.kt
    /jvm/app.kt
    /js/app.kt    
```

### Imported vs child modules

When you choosing between external module that you can import and submodule, you should understand differences described below.

Here is things that submodules can do, but imported module not:
- submodule can see internal declarations of parent module

#### Private vs public submodules

As described above, the main difference between public and private submodules is that:
- public is for some implementation detail that **can** be used in parent module.
- private is for supplementary or variant-dependent things that **cannot** be used in parent module, but:
    - still can see all internal declarations of the parent modules
    - still can be used in parent module using the `expect` declarations
    - still can be published, but only as the `variant` of parent module
    - only private submodules can create `actual` declarations of `expect`\`ed one in parent module
    - supplementary relations implicitly defines mirrored parent-child relationship of the correspoding explict parent modules relationship

#### Mixing public and private submodules    



### Custom platforms and variants

```
target jvm {
    target 8 {
        attribute jvm-version 1.8
    }
}
```

### Custom build dimensions

Above we have used only 2 predefined build dimensions: 
- `platform` (`jvm`/`js`/`native`) 
- `supplementary kind` (`root`/`test`/`becnhamrks`).

Let's declare one more dimensions, for example `optimizations-level` (`dev`/`prod`).

**TODO**

```
target jvm {
    tests {
        dev
        prod
    }

    dev
    prod
}
```

### Optional proposals

#### Submodule files

Alternatively, submodule files can be named as `filename.submodule-name.kt` and placed in parent directory.
Example:

 ```
 /ToDoApp
     kotlin.mod
     App.kt
     App.test.kt
     App.jvm.kt
     App.jvm.test.kt
     App.js.kt
     App.js.test.kt
     /utils
         dates.kt
         dates.test.kt
         dates.jvm.kt
         dates.js.kt
 ```

## Model representation, DSL, build plugins

## Execution/artifacts model

## Possible Gradle integration

