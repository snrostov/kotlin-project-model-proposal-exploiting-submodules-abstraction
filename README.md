## Project model

`Module` - an application that you can run or library that you can depend on.

### File layout

Module is just a directory with a `kotlin.mod` file inside and on or more `*.kt` files. 
`kotlin.mod` file contains module definition and may be empty.

```
/ToDoApp
    kotlin.mod
    app.kt
```

```kotlin
// kotlin.mod
module github.com/username/libname  

import stdlib                       
```

```kotlin
// app.kt
println("hello, world!")
```

### Module dependencies

The module can depend on other modules by using `import` or `private import` directive.
By default all imports are exposed to the module users.
This may be changed by using `private import` directive instead.

```kotlin
module kotlin.org/samples/ToDoApp

import kotlin.org/stdlib
private import kotlin.org/uiLib
```

```kotlin
module kotlin.org/uiLib

import kotlin.org/ui
private import kotlin.org/uiJuggler 
```

![](img/imgs/dependencies.svg)

### Target platform

Each module produces a platform-specific artifact: executable or library.
Platform is configured using the `target` directive.

```kotlin
module kotlin.org/samples/ToDoApp

import kotlin.org/stdlib
private import kotlin.org/uiLib
private import kotlin.org/datesLib

target android
```

The module can have multiple artifacts, for example for different platforms.
In this case, all dependencies and all sources should be compatible with declared target platforms.

```kotlin
module kotlin.org/dateUtils

import kotlin.org/dates

target jvm
target js
```

### Submodules

The module can have `public` and `private` `submodules`.
Submodules derives most of parent module settings: targets, dependencies, used plugins and some other.

Submodules is declared by just creating subdirectory (even without `kotlin.mod` file inside).
By default submodules have public visibility and it's package name is changed to sub directory name.
Submodule info can be placed inside parent's `kotlin.mod` under the `module`/`private module` directive
or with it's own `kotlin.mod` file inside subdirectory.

Submodules have an implicit import of parent module and can see its public and internal declarations.
Parent module also have implicit import of all public submodules, but can see only it's public declarations.
Private submodules is not imported by default.

Public submodules is replacement for kotlin packages.

### Tests: private submodules

Private submodules can be used for supplementary things like tests, integration tests, benchmarks and so on.

There is shorthand for creating `private module test`: you can type just `test`.

```
/ToDoApp
    kotlin.mod
    App.kt
    /test
        AppTest.kt
    /utils
        dates.kt
        /test
            datesTest.kt
```

```kotlin
module kotlin.org/samples/ToDoApp

import kotlin.org/stdlib

test {   
    import kotlin.org/test
}

module utils {
    test {
        import kotlin.org/test
    }
}
```

![](img/imgs/submodules.svg)

#### Implicit parent-child tests relationship

In previous example, we are explicitly define dependency from `utils/test` to `kotlin.org/test`.
But it is already defined in root `test` module and it would be nice if that dependency was derived in same way as `stdlib` imported in root module also accessiable in `utils`.
The problem is that `test` is not parent for `utils/test`.
But we can infer that additional parent-child relationship between submodule supplementary of same kinds (`test` in this case). 

![](img/imgs/submodule-relations.svg)

This implicit supplementary parent-child relationship useful in case of many related submodule which is frequently appears in [advanced multi-platform cases]().

#### Custom supplementary (benchmarks, integration tests...)

Actually `test` is just shorthand for `supplementary module test`.
You can define custom supplementary module:

```
supplementary module benchmarks {
    import kotlin.org/benchmarks
}
``` 

And the will have corresponding implicit parent-child relationship between submodules.

As and advencaed concept, you can define your own build dimensions. This is described in separate section.

### Multiplatform modules with platform specifics

It is possible to create a multiplatform module that have specific platform code.
 
Platform specifics can be declared in private submodules that can be exposed as a so called `variant` of the parent public module. 
Actually, the `target` declaration already creates a private submodule and exposed as a `module variant`.

Example:

```
module kotlin.org/dateUtils

import kotlin.org/dates

target jvm
target js
```

Files:

```
/dateUtils
    kotlin.mod
    dateUtils.kt
    /jvm
        dateUtils.kt
    /js
        dateUtils.kt
```

or

```
/dateUtils
    kotlin.mod
    dateUtils.kt    
    dateUtils.jvm.kt    
    dateUtils.js.kt
```

Target's private submodule can have it's own target specific imports and settings. 
All the setting can be declared under target directive or inside it's own `kotlin.mod`.

```
module kotlin.org/dateUtils

import kotlin.org/dates

target jvm {
    import java.utils.date
}

target js {
    import moment.js
}
```

### Variant aware dependency resolution

Dependency to the module with multiple variants are resolved in special way: user of that module will see only peaces of required variant.
Let's take a look to example of two jvm/js dependent modules: `dateUtils` described in the previous section and `uiUtils` described below.

```
module kotlin.org/uiUtils

import kotlin.org/dateUtils

target jvm
target js
```

![](img/imgs/variant-aware-1.svg)

Despite the fact that we declared only one import to `kotlin.org/dateUtils`, our `uiUtils` `jvm` variant automatically will import `jvm` part of  `kotlin.org/dateUtils` (but not `js` ). The same for js: it will automatically import `js` part of `kotlin.org/dateUtils`. 

![](img/imgs/variant-aware-2.svg)

This feature is called `variant aware dependency resolution` and prevents us to duplicate dependencies in each target manually.

### Platform-specific declarations

The general way to extract platform-specific code is building a set of interfaces in the common code and implementing these interfaces in platform-specific modules. However, this approach is not ideal in cases when you have a library on one of the platforms that implements the functionality you need, and you'd like to use the API of this library directly without extra wrappers. Also, it requires common declarations to be expressed as interfaces, which doesn't cover all possible cases.

As an alternative, Kotlin provides a mechanism of `expected` and `actual` declarations. With this mechanism, a common code can define expected declarations, and a platform specific code can provide actual declarations corresponding to the expected ones. To see how this works, let's look at an example first. This part of root common code:

```kotlin
expect class Foo(bar: String) {
    fun frob()
}

fun main() {
    Foo("Hello").frob()
}
```  

And this is the corresponding JVM variant private submodule:

```kotlin
actual class Foo actual constructor(val bar: String) {
    actual fun frob() {
        println("Frobbing the $bar")
    }
}
```

.... https://kotlinlang.org/docs/reference/platform-specific-declarations.html

### Common code for group of platforms

```
module kotlin.org/dateUtils

import kotlin.org/dates

target jvm

target js {
    target browser
    target nodejs
}

target native {
    target iOS
    target macOS
}
```

```
/ToDoApp
    common.kt
    /jvm/app.kt
    /js
        jsCommon.kt
        /browser/app.kt
        /nodejs/app.kt
    /native
        nativeCommon.kt
        /iOS/app.kt
        /macOS/app.kt
```

### Multiparent private submodules

Sometimes you need to use extract traits that should be combined into different platforms.


```
module kotlin.org/dateUtils

import kotlin.org/dates

private module managed-memory-common

target jvm {
    extends managed-memory-common
}

target js {
    extends managed-memory-common
}

target iOS
```

```
/ToDoApp
    common.kt
    /managed-memory-common/common.kt
    /jvm/app.kt
    /js/app.kt    
```

### Exposing tests as public module variant

You can expose test submodules as parent public variant. In this case, users of your module can see declaration of your test submodules in their corresponding test modules.

This will work for all supplementary modules.

### Imported vs child submodules

When you choosing between external module that you can import and submodule, you should understand differences described below.

Only child submodule can:
- see internal declarations of parent module
- create actual declarations for parent module
- submodule parent-child relations are implicitly duplucated on supplementary module co-graph

Module that have an import to another module can't do this things.

### Custom platforms and variants

```
target jvm {
    target 8 {
        attribute jvm-version 1.8
    }
}
```

### Custom build dimensions

Above we have used only 2 predefined build dimensions: `platform` (`jvm`/`js`/`native`) and `supplementary kind` (`root`/`test`/`becnhamrks`).

Let's declare one more dimensions, for example `optimizations-level` (`dev`/`prod`).

```
target jvm {
    tests {
        dev
        prod
    }

    dev
    prod
}
```

### Optional proposals

#### Submodule files

Alternatively, submodule files can be named as `filename.submodule-name.kt` and placed in parent directory.
Example:

 ```
 /ToDoApp
     kotlin.mod
     App.kt
     App.test.kt
     App.jvm.kt
     App.jvm.test.kt
     App.js.kt
     App.js.test.kt
     /utils
         dates.kt
         dates.test.kt
         dates.jvm.kt
         dates.js.kt
 ```

## Model representation, DSL, build plugins

## Execution/artifacts model

## Possible Gradle integration

